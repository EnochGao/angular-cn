/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import * as o from '../../../../output/output_ast';
import * as ir from '../../ir';
import {ComponentCompilation} from '../compilation';

export interface VariableOptimizationOptions {
  conservative: boolean;
}

/**
 * Optimize variables declared and used in the IR.
 *
 * 优化 IR 中声明和使用的变量。
 *
 * Variables are eagerly generated by pipeline stages for all possible values that could be
 * referenced. This stage processes the list of declared variables and all variable usages,
 * and optimizes where possible. It performs 3 main optimizations:
 *
 * 流水线阶段急切地为可以引用的所有可能值生成变量。 此阶段处理声明变量列表和所有变量用法，并在可能的情况下进行优化。 它执行 3 个主要优化：
 *
 * - It transforms variable declarations to side effectful expressions when the
 *   variable is not used, but its initializer has global effects which other
 *   operations rely upon.
 *
 *   当不使用变量时，它将变量声明转换为副作用表达式，但它的初始化程序具有其他操作所依赖的全局效果。
 *
 * - It removes variable declarations if those variables are not referenced and
 *   either they do not have global effects, or nothing relies on them.
 *
 *   如果这些变量未被引用并且它们没有全局影响，或者没有任何依赖它们，它会删除变量声明。
 *
 * - It inlines variable declarations when those variables are only used once
 *   and the inlining is semantically safe.
 *
 *   当这些变量只使用一次并且内联在语义上是安全的时，它会内联变量声明。
 *
 * To guarantee correctness, analysis of "fences" in the instruction lists is used to determine
 * which optimizations are safe to perform.
 *
 * 为了保证正确性，指令列表中的“围栏”分析用于确定执行哪些优化是安全的。
 *
 */
export function phaseVariableOptimization(
    cpl: ComponentCompilation, options: VariableOptimizationOptions): void {
  for (const [_, view] of cpl.views) {
    optimizeVariablesInOpList(view.create, options);
    optimizeVariablesInOpList(view.update, options);

    for (const op of view.create) {
      if (op.kind === ir.OpKind.Listener) {
        optimizeVariablesInOpList(op.handlerOps, options);
      }
    }
  }
}

/**
 * A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates
 * how that expression can be optimized in relation to other expressions or instructions.
 *
 * 表达式的[栅栏](https://en.wikipedia.org/wiki/Memory_barrier)标志，指示如何相对于其他表达式或指令优化该表达式。
 *
 * `Fence`s are a bitfield, so multiple flags may be set on a single expression.
 *
 * `Fence` 是位域，因此可以在单个表达式上设置多个标志。
 *
 */
enum Fence {
  /**
   * Empty flag \(no fence exists\).
   *
   * 空标志（不存在栅栏）。
   *
   */
  None = 0b000,

  /**
   * A context read fence, meaning that the expression in question reads from the "current view"
   * context of the runtime.
   *
   * 上下文读取栅栏，意味着相关表达式从运行时的“当前视图”上下文中读取。
   *
   */
  ViewContextRead = 0b001,

  /**
   * A context write fence, meaning that the expression in question writes to the "current view"
   * context of the runtime.
   *
   * 上下文写栅栏，意味着所讨论的表达式写入运行时的“当前视图”上下文。
   *
   * Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which
   * change the view context do so based on the current one.
   *
   * 请注意，所有 `ContextWrite` 栅栏都是隐式的 `ContextRead` 栅栏，因为更改视图上下文的操作是基于当前视图上下文执行的。
   *
   */
  ViewContextWrite = 0b011,

  /**
   * Indicates that a call is required for its side-effects, even if nothing reads its result.
   *
   * 表示需要对其副作用进行调用，即使没有任何内容读取其结果。
   *
   * This is also true of `ViewContextWrite` operations **if** they are followed by a
   * `ViewContextRead`.
   *
   * **如果**`ViewContextWrite` 操作后跟 `ViewContextRead` ，这也是如此。
   *
   */
  SideEffectful = 0b100,
}

/**
 * Summary data collected for each `Op` in a list.
 *
 * 为列表中的每个 `Op` 收集的摘要数据。
 *
 * Tracking this data per operation allows the optimizer to process operations at a higher level
 * than always scanning expressions.
 *
 * 跟踪每个操作的数据允许优化器在比始终扫描表达式更高的级别处理操作。
 *
 */
interface OpInfo {
  /**
   * A `Set` of variables referenced by expressions in this operation.
   *
   * 此操作中的表达式引用的一 `Set` 变量。
   *
   */
  variablesUsed: Set<ir.XrefId>;

  /**
   * Flags indicating any `Fence`s present for this operation.
   *
   * 指示此操作存在的任何 `Fence` 的标志。
   *
   */
  fences: Fence;
}

/**
 * Process a list of operations and optimize variables within that list.
 *
 * 处理操作列表并优化该列表中的变量。
 *
 */
function optimizeVariablesInOpList(
    ops: ir.OpList<ir.CreateOp|ir.UpdateOp>, options: VariableOptimizationOptions): void {
  const varDecls = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp|ir.UpdateOp>>();
  const varUsages = new Map<ir.XrefId, number>();

  // Track variables that are used outside of the immediate operation list. For example, within
  // `ListenerOp` handler operations of listeners in the current operation list.
  const varRemoteUsages = new Set<ir.XrefId>();
  const opMap = new Map<ir.CreateOp|ir.UpdateOp, OpInfo>();

  // First, extract information about variables declared or used within the whole list.
  for (const op of ops) {
    if (op.kind === ir.OpKind.Variable) {
      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {
        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);
      }
      varDecls.set(op.xref, op);
      varUsages.set(op.xref, 0);
    }

    opMap.set(op, collectOpInfo(op));
    countVariableUsages(op, varUsages, varRemoteUsages);
  }

  // The next step is to remove any variable declarations for variables that aren't used. The
  // variable initializer expressions may be side-effectful, so they may need to be retained as
  // expression statements.

  // Track whether we've seen an operation which reads from the view context yet. This is used to
  // determine whether a write to the view context in a variable initializer can be observed.
  let contextIsUsed = false;

  // Note that iteration through the list happens in reverse, which guarantees that we'll process
  // all reads of a variable prior to processing its declaration.
  for (const op of ops.reversed()) {
    const opInfo = opMap.get(op)!;

    if (op.kind === ir.OpKind.Variable && varUsages.get(op.xref)! === 0) {
      // This variable is unused and can be removed. We might need to keep the initializer around,
      // though, if something depends on it running.
      if ((contextIsUsed && opInfo.fences & Fence.ViewContextWrite) ||
          (opInfo.fences & Fence.SideEffectful)) {
        // This variable initializer has a side effect which must be retained. Either:
        //  * it writes to the view context, and we know there is a future operation which depends
        //    on that write, or
        //  * it's an operation which is inherently side-effectful.
        // We can't remove the initializer, but we can remove the variable declaration itself and
        // replace it with a side-effectful statement.
        const stmtOp = ir.createStatementOp(op.initializer.toStmt()) as ir.UpdateOp;
        opMap.set(stmtOp, opInfo);
        ir.OpList.replace(op as ir.UpdateOp, stmtOp);
      } else {
        // It's safe to delete this entire variable declaration as nothing depends on it, even
        // side-effectfully. Note that doing this might make other variables unused. Since we're
        // iterating in reverse order, we should always be processing usages before declarations
        // and therefore by the time we get to a declaration, all removable usages will have been
        // removed.
        uncountVariableUsages(op, varUsages);
        ir.OpList.remove(op as ir.UpdateOp);
      }

      opMap.delete(op);
      varDecls.delete(op.xref);
      varUsages.delete(op.xref);
      continue;
    }

    // Does this operation depend on the view context?
    if (opInfo.fences & Fence.ViewContextRead) {
      contextIsUsed = true;
    }
  }

  // Next, inline any remaining variables with exactly one usage.
  const toInline: ir.XrefId[] = [];
  for (const [id, count] of varUsages) {
    // We can inline variables that:
    //  - are used once
    //  - are not used remotely
    if (count !== 1) {
      // We can't inline this variable as it's used more than once.
      continue;
    }

    if (varRemoteUsages.has(id)) {
      // This variable is used once, but across an operation boundary, so it can't be inlined.
      continue;
    }

    toInline.push(id);
  }

  let candidate: ir.XrefId|undefined;
  while (candidate = toInline.pop()) {
    // We will attempt to inline this variable. If inlining fails (due to fences for example),
    // no future operation will make inlining legal.
    const decl = varDecls.get(candidate)!;
    const varInfo = opMap.get(decl as ir.CreateOp | ir.UpdateOp)!;

    // Scan operations following the variable declaration and look for the point where that variable
    // is used. There should only be one usage given the precondition above.
    for (let targetOp = decl.next!; targetOp.kind !== ir.OpKind.ListEnd;
         targetOp = targetOp.next!) {
      const opInfo = opMap.get(targetOp)!;

      // Is the variable used in this operation?
      if (opInfo.variablesUsed.has(candidate)) {
        if (options.conservative && !allowConservativeInlining(decl, targetOp)) {
          // We're in conservative mode, and this variable is not eligible for inlining into the
          // target operation in this mode.
          break;
        }

        // Yes, try to inline it. Inlining may not be successful if fences in this operation before
        // the variable's usage cannot be safely crossed.
        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {
          // Inlining was successful! Update the tracking structures to reflect the inlined
          // variable.
          opInfo.variablesUsed.delete(candidate);

          // Add all variables used in the variable's initializer to its new usage site.
          for (const id of varInfo.variablesUsed) {
            opInfo.variablesUsed.add(id);
          }

          // Merge fences in the variable's initializer into its new usage site.
          opInfo.fences |= varInfo.fences;

          // Delete tracking info related to the declaration.
          varDecls.delete(candidate);
          varUsages.delete(candidate);
          opMap.delete(decl as ir.CreateOp | ir.UpdateOp);

          // And finally, delete the original declaration from the operation list.
          ir.OpList.remove(decl as ir.UpdateOp);
        }

        // Whether inlining succeeded or failed, we're done processing this variable.
        break;
      }

      // If the variable is not used in this operation, then we'd need to inline across it. Check if
      // that's safe to do.
      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {
        // We can't safely inline this variable beyond this operation, so don't proceed with
        // inlining this variable.
        break;
      }
    }
  }
}

/**
 * Given an `ir.Expression`, returns the `Fence` flags for that expression type.
 *
 * 给定一个 `ir.Expression` ，返回该表达式类型的 `Fence` 标志。
 *
 */
function fencesForIrExpression(expr: ir.Expression): Fence {
  switch (expr.kind) {
    case ir.ExpressionKind.NextContext:
      return Fence.ViewContextWrite;
    case ir.ExpressionKind.RestoreView:
      return Fence.ViewContextWrite | Fence.SideEffectful;
    case ir.ExpressionKind.Reference:
      return Fence.ViewContextRead;
    default:
      return Fence.None;
  }
}

/**
 * Build the `OpInfo` structure for the given `op`. This performs two operations:
 *
 * 为给定的 `op` 构建 `OpInfo` 结构。 这执行两个操作：
 *
 * - It tracks which variables are used in the operation's expressions.
 *
 *   它跟踪操作表达式中使用了哪些变量。
 *
 * - It rolls up fence flags for expressions within the operation.
 *
 *   它为操作中的表达式汇总栅栏标志。
 *
 */
function collectOpInfo(op: ir.CreateOp|ir.UpdateOp): OpInfo {
  let fences = Fence.None;
  const variablesUsed = new Set<ir.XrefId>();
  ir.visitExpressionsInOp(op, expr => {
    if (!ir.isIrExpression(expr)) {
      return;
    }

    switch (expr.kind) {
      case ir.ExpressionKind.ReadVariable:
        variablesUsed.add(expr.xref);
        break;
      default:
        fences |= fencesForIrExpression(expr);
    }
  });
  return {fences, variablesUsed};
}

/**
 * Count the number of usages of each variable, being careful to track whether those usages are
 * local or remote.
 *
 * 计算每个变量的使用次数，注意跟踪这些使用是本地的还是远程的。
 *
 */
function countVariableUsages(
    op: ir.CreateOp|ir.UpdateOp, varUsages: Map<ir.XrefId, number>,
    varRemoteUsage: Set<ir.XrefId>): void {
  ir.visitExpressionsInOp(op, (expr, flags) => {
    if (!ir.isIrExpression(expr)) {
      return;
    }

    if (expr.kind !== ir.ExpressionKind.ReadVariable) {
      return;
    }

    const count = varUsages.get(expr.xref);
    if (count === undefined) {
      // This variable is declared outside the current scope of optimization.
      return;
    }
    varUsages.set(expr.xref, count + 1);

    if (flags & ir.VisitorContextFlag.InChildOperation) {
      varRemoteUsage.add(expr.xref);
    }
  });
}

/**
 * Remove usages of a variable in `op` from the `varUsages` tracking.
 *
 * 从 `varUsages` 跟踪中删除 `op` 中变量的使用。
 *
 */
function uncountVariableUsages(
    op: ir.CreateOp|ir.UpdateOp, varUsages: Map<ir.XrefId, number>): void {
  ir.visitExpressionsInOp(op, expr => {
    if (!ir.isIrExpression(expr)) {
      return;
    }

    if (expr.kind !== ir.ExpressionKind.ReadVariable) {
      return;
    }

    const count = varUsages.get(expr.xref);
    if (count === undefined) {
      // This variable is declared outside the current scope of optimization.
      return;
    } else if (count === 0) {
      throw new Error(
          `Inaccurate variable count: ${expr.xref} - found another read but count is already 0`);
    }
    varUsages.set(expr.xref, count - 1);
  });
}

/**
 * Checks whether it's safe to inline a variable across a particular operation.
 *
 * 检查在特定操作中内联变量是否安全。
 *
 * @param fences the fences of the operation which the inlining will cross
 *
 * 内联将跨越的操作的围栏
 *
 * @param declFences the fences of the variable being inlined.
 *
 * 内联变量的栅栏。
 *
 */
function safeToInlinePastFences(fences: Fence, declFences: Fence): boolean {
  if (fences & Fence.ViewContextWrite) {
    // It's not safe to inline context reads across context writes.
    if (declFences & Fence.ViewContextRead) {
      return false;
    }
  } else if (fences & Fence.ViewContextRead) {
    // It's not safe to inline context writes across context reads.
    if (declFences & Fence.ViewContextWrite) {
      return false;
    }
  }
  return true;
}

/**
 * Attempt to inline the initializer of a variable into a target operation's expressions.
 *
 * 尝试将变量的初始值设定项内联到目标操作的表达式中。
 *
 * This may or may not be safe to do. For example, the variable could be read following the
 * execution of an expression with fences that don't permit the variable to be inlined across them.
 *
 * 这样做可能安全也可能不安全。 例如，可以在执行带有不允许变量跨过它们内联的栅栏的表达式后读取变量。
 *
 */
function tryInlineVariableInitializer(
    id: ir.XrefId, initializer: o.Expression, target: ir.CreateOp|ir.UpdateOp,
    declFences: Fence): boolean {
  // We use `ir.transformExpressionsInOp` to walk the expressions and inline the variable if
  // possible. Since this operation is callback-based, once inlining succeeds or fails we can't
  // "stop" the expression processing, and have to keep track of whether inlining has succeeded or
  // is no longer allowed.
  let inlined = false;
  let inliningAllowed = true;

  ir.transformExpressionsInOp(target, (expr, flags) => {
    if (!ir.isIrExpression(expr)) {
      return expr;
    }

    if (inlined || !inliningAllowed) {
      // Either the inlining has already succeeded, or we've passed a fence that disallows inlining
      // at this point, so don't try.
      return expr;
    } else if (
        (flags & ir.VisitorContextFlag.InChildOperation) && (declFences & Fence.ViewContextRead)) {
      // We cannot inline variables that are sensitive to the current context across operation
      // boundaries.
      return expr;
    }

    switch (expr.kind) {
      case ir.ExpressionKind.ReadVariable:
        if (expr.xref === id) {
          // This is the usage site of the variable. Since nothing has disallowed inlining, it's
          // safe to inline the initializer here.
          inlined = true;
          return initializer;
        }
        break;
      default:
        // For other types of `ir.Expression`s, whether inlining is allowed depends on their fences.
        const exprFences = fencesForIrExpression(expr);
        inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);
        break;
    }
    return expr;
  }, ir.VisitorContextFlag.None);
  return inlined;
}

/**
 * Determines whether inlining of `decl` should be allowed in "conservative" mode.
 *
 * 确定在“保守”模式下是否应允许 `decl` 内联。
 *
 * In conservative mode, inlining behavior is limited to those operations which the
 * `TemplateDefinitionBuilder` supported, with the goal of producing equivalent output.
 *
 * 在保守模式下，内联行为仅限于 `TemplateDefinitionBuilder` 支持的那些操作，目的是产生等效输出。
 *
 */
function allowConservativeInlining(
    decl: ir.VariableOp<ir.CreateOp|ir.UpdateOp>, target: ir.Op<ir.CreateOp|ir.UpdateOp>): boolean {
  // TODO(alxhub): understand exactly how TemplateDefinitionBuilder approaches inlining, and record
  // that behavior here.
  switch (decl.variable.kind) {
    case ir.SemanticVariableKind.Identifier:
      return false;
    case ir.SemanticVariableKind.Context:
      // Context can only be inlined into other variables.
      return target.kind === ir.OpKind.Variable;
    default:
      return true;
  }
}
