@name Hydration Node Mismatch

@category runtime

@shortDescription During hydration, Angular expected a DOM node, but either the actual DOM was different or was not found.

@description

This error means that during the hydration process, Angular expected a DOM structure as rendered and annotated during server side rendering. However, on the client, the DOM tree was different than the server rendered DOM tree.

这个错误意味着在水合过程中，Angular 期望 DOM 结构在服务端渲染期间被渲染和注释。 但是，在客户端，DOM 树与服务器渲染的 DOM 树不同。

This error typically happens due to direct DOM manipulation using native browser APIs that alter the DOM structure outside of what Angular produced. You can resolve this by refactoring the component to use native Angular APIs instead of native APIs. If that's not possible, you can add the `ngSkipHydration` attribute to your component's host node, which will disable hydration for the component and its children. `ngSkipHydration` should only be used as a last resort and should be considered a bug that needs to be fixed.

此错误通常是由于使用原生浏览器 API 直接操作 DOM 而发生的，这些 API 在 Angular 生成的内容之外更改了 DOM 结构。 你可以通过重构组件以使用原生 Angular API 而不是原生 API 来解决此问题。 如果那不可能，你可以将 `ngSkipHydration` 属性添加到组件的宿主节点，这将禁用组件及其子组件的水合。 `ngSkipHydration` 只能作为最后的手段使用，并且应该被视为需要修复的错误。

More information about hydration can be found in [this guide](guide/hydration).

有关水合的更多信息，请参阅[本指南](guide/hydration)。

The following example will trigger the error.

以下示例将触发错误。

```typescript
@Component({
  standalone: true,
  selector: 'example-cmp',
  template: '<div><span>world</span></div>',
})
export class ExampleCmp {
  hostElement = inject(ElementRef).nativeElement;

  ngOnInit() {
    // Create a new <p> element with the `Hello` text inside
    const newNode = document.createElement('p');
    newNode.innerHTML = 'Hello';

    // Insert the <p> before the first element. Since Angular has no information
	  // about the <p> element, it will be looking for the <div> element at the first
	  // element position instead. As a result, a hydration mismatch error would be
	  // thrown. Instead, update component's template to create the <p> element.
	  this.hostElement.insertBefore(newNode, this.hostElement.firstChild);
	}
}
```

@debugging

The error message in the developer console should contain information on a specific part of the application's DOM structure that is causing the problem. Review that part of the application for hydration-related errors, such as direct DOM manipulation using native APIs.
Check that your template has valid HTML structure. See more information in the [hydration guide](guide/hydration#valid-html-structure).
You can add the `ngSkipHydration` attribute to your component host node as a possible workaround.

开发人员控制台中的错误消息应包含有关导致问题的应用程序 DOM 结构的特定部分的信息。 检查应用程序的那部分是否存在与水合相关的错误，例如使用原生 API 的直接 DOM 操作。 检查你的模板是否具有有效的 HTML 结构。 请参阅[水合指南](guide/hydration#valid-html-structure)中的更多信息。 作为一种可能的解决方法，你可以将 `ngSkipHydration` 属性添加到你的组件宿主节点。

If your application works in development environment, but you see hydration errors in production builds, make sure that the generated HTML that is delivered to a browser contains comment nodes produced by Angular during the rendering on the server. Those comment nodes are used by Angular runtime as anchors for view containers \(with and without hydration\) and hydration process expects them to be present at their original locations. If you have a custom logic to remove comment nodes from the HTML generated by the server-side rendering or you've configured your CDN to remove them before serving the content - disable the comment nodes removal and check if hydration errors are gone.

如果你的应用程序在开发环境中运行，但你在生产构建中看到混合错误，请确保生成的交付给浏览器的 HTML 包含 Angular 在服务器上渲染期间生成的注释节点。 Angular 运行时使用这些注释节点作为视图容器的锚点（有和没有水化），水化过程期望它们出现在它们的原始位置。 如果你有自定义逻辑从服务端渲染生成的 HTML 中删除注释节点，或者你已将 CDN 配置为在提供内容之前删除它们 - 禁用注释节点删除并检查水合错误是否消失。
