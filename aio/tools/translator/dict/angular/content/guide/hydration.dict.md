Hydration

水合（Hydration）

What is hydration

什么是水合

Hydration is the process that restores the server side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes.

水合是指在客户端恢复服务端渲染出的应用程序的过程。这包括复用服务端渲染的 DOM 结构、持久化应用程序状态、传输服务端已经获取到的应用程序数据，还有一些其他过程。

Why is hydration important?

为什么水合很重要？

Hydration improves application performance by avoiding extra work to re-create DOM nodes. Instead, Angular tries to match existing DOM elements to the applications structure at runtime and reuses DOM nodes when possible. This results in a performance improvement that can be measured using [Core Web Vitals \(CWV\)](https://web.dev/learn-core-web-vitals/) statistics, such as reducing the First Input Delay \([FID](https://web.dev/fid/)\) and Largest Contentful Paint \([LCP](https://web.dev/lcp/)\), as well as Cumulative Layout Shift \([CLS](https://web.dev/cls/)\). Improving these numbers also affects things like SEO performance.

水合通过避免重新创建 DOM 节点的额外工作来提高应用程序性能。而 Angular 会试图在运行时将现有的 DOM 元素与应用程序结构相匹配，只在可能的情况下复用 DOM 节点。这能改进性能，可以使用[核心 Web 体验（CWV）](https://web.dev/learn-core-web-vitals/)这组统计数据来衡量，例如减少首次输入延迟（[FID](https://web.dev/fid/)）和最大内容绘制（[LCP](https://web.dev/lcp/)），以及累积布局偏移（[CLS](https://web.dev/cls/)）。改善这些数据也会影响诸如 SEO 性能之类的指标。

Without hydration enabled, server side rendered Angular applications will destroy and re-render the application's DOM, which may result in a visible UI flicker. This re-rendering can negatively impact [Core Web Vitals](https://web.dev/learn-core-web-vitals/) like [LCP](https://web.dev/lcp/) and cause a layout shift. Enabling hydration allows the existing DOM to be re-used and prevents a flicker.

如果不启用水合，服务端渲染的 Angular 应用程序将销毁并重新渲染应用程序的 DOM，这可能会导致可见的 UI 闪烁。这种重新渲染会对像 [LCP](https://web.dev/lcp/) 这样的 [核心 Web 体验](https://web.dev/learn-core-web-vitals/)产生负面影响，并导致布局变化。启用水合能让你复用现有的 DOM 并防止闪烁。

<a id="how-to-enable"></a>



How do you enable hydration in Angular

如何在 Angular 中启用水合

Before you can get started with hydration, you must have a server side rendered \(SSR\) application. Follow the [Angular Universal Guide](/guide/universal) to enable server side rendering first. Once you have SSR working with your application, you can enable hydration by visiting your main app component or module and importing `provideClientHydration` from `@angular/platform-browser`. You'll then add that provider to your app's bootstrapping providers list.

在开始水合之前，你必须有一个服务端渲染（SSR）的应用程序。首先按照 [Angular Univeral 指南](/guide/universal)启用服务端渲染。一旦你的应用程序使用了 SSR，就可以通过为主要组件或模块从 `@angular/platform-browser` 导入 `provideClientHydration` 来启用水合。然后，你还要把 `provideClientHydration` 返回的提供者添加到应用程序的引导程序提供者列表中。

Alternatively if you are using NgModules, you would add `provideClientHydration` to your root app module's provider list.

或者，如果你在使用 NgModules，可以将 `provideClientHydration` 添加到根应用程序模块的提供者列表中。

After you've followed these steps and have started up your server, load your application in the browser.

完成这些步骤并启动服务端后，在浏览器中加载你的应用程序。

While running an application in dev mode, you can confirm hydration is enabled by opening the Developer Tools in your browser and viewing the console. You should see a message that includes hydration-related stats, such as the number of components and nodes hydrated. Note: Angular calculates the stats based on all components rendered on a page, including those that come from third-party libraries.

在开发模式下运行应用程序时，你可以通过在浏览器中打开开发者工具并查看控制台来确认已启用水合。你应该会看到一条消息，其中包含与水合相关的统计信息，例如水合的组件数和节点数。注意：Angular 会根据页面上渲染的所有组件计算统计信息，包括那些来自第三方库的组件。

<a id="constraints"></a>



Constraints

约束条件

Hydration imposes a few constraints on your application that are not present without hydration enabled. Your application must have the same generated DOM structure on both the server and the client. The process of hydration expects the DOM tree to have the same structure in both places. This also includes whitespaces and comment nodes that Angular produces during the rendering on the server. Those whitespaces and nodes must be present in the HTML generated by the server-side rendering process.

水合对你的应用程序施加了一些限制，这些限制在没有启用水合的情况下是不存在的。你的应用程序必须在服务端和客户端具有相同的生成的 DOM 结构。水合过程期望 DOM 树在两个地方具有相同的结构。这还包括 Angular 在服务端渲染期间生成的空白和注释节点。这些空白和注释节点必须出现在服务端渲染过程生成的 HTML 中。

If there is a mismatch between server and client DOM tree structures, the hydration process will encounter problems attempting to match up what was expected to what is actually present in the DOM. Components that do direct DOM manipulation using native DOM APIs are the most common culprit.

如果服务端和客户端的 DOM 树结构不匹配，当水合过程试图将预期的内容与 DOM 中实际存在的内容相匹配时就会遇到问题。使用原生 DOM API 进行直接 DOM 操作的组件是最常见的罪魁祸首。

<a id="dom-manipulation"></a>



Direct DOM Manipulation

直接 DOM 操作

If you have components that manipulate the DOM using native DOM APIs, the hydration process will encounter errors. Specific cases where DOM manipulation is a problem are situations like accessing the `document`, querying for specific elements, and injecting additional nodes using `appendChild`. Detaching DOM nodes and moving them to other locations will also result in errors.

如果你有使用原生 DOM API 操作 DOM 的组件，水合过程将遇到错误。DOM 操作出问题的具体情况包括访问 `document` 、查询特定元素以及使用 `appendChild` 注入其他节点等。分离 DOM 节点并将它们移动到其他位置也会导致错误。

This is because Angular is unaware of these DOM changes and cannot resolve them during the hydration process. Angular will expect a certain structure, but it will encounter a different structure when attempting to hydrate. This mismatch will result in hydration failure and throw a DOM mismatch error \([see below](#errors)\).

这是因为 Angular 不了解这些 DOM 变化，并且无法在水合过程中解决它们。Angular 本来期望某种结构，但在尝试水合时遇到了另一种结构。这种差异将导致水合失败并引发 DOM 不匹配错误（[见下文](#errors)）。

It is best to refactor your component to avoid this sort of DOM manipulation. Try to use Angular APIs to do this work, if you can. If you cannot refactor this behavior, use the `ngSkipHydration` attribute \([described below](#ngskiphydration)\) until you can refactor into a hydration friendly solution.

最好重构你的组件以避免此类 DOM 操作。如果可以，请尝试使用 Angular API 来完成这项工作。如果你无法重构此行为，请使用 `ngSkipHydration` 属性（[如下所述](#ngskiphydration)），直到你可以把它重构为对水合友好的解决方案。

Valid HTML structure

有效的 HTML 结构

There are a few cases where if you have a component template that does not have valid HTML structure, this could result in a DOM mismatch error during hydration.

在某些情况下，如果你的组件模板没有有效的 HTML 结构，可能会导致在水合期间出现 DOM 不匹配错误。

As an example, here are some of the most common cases of this issue.

例如，以下是此问题的一些最常见案例。

`<table>` without a `<tbody>`

`<table>` 标签中没有 `<tbody>`

`<div>` inside a `<p>`

`<div>`标签 位于 `<p>` 中

`<a>` inside an `<h1>`

`<a>`标签 位于 `<h1>` 中

`<a>` inside another `<a>`

`<a>` 标签位于另一个 `<a>` 中

If you are uncertain about whether your HTML is valid, you can use a [syntax validator](https://validator.w3.org/) to check it.

如果你不确定你的 HTML 是否有效，可以使用[语法验证器](https://validator.w3.org/)来检查它。

<a id="preserve-whitespaces"></a>



Preserve Whitespaces Configuration

保留空白字符配置

When using the hydration feature, we recommend using the default setting of `false` for `preserveWhitespaces`. If this setting is not in your tsconfig, the value will be `false` and no changes are required. If you choose to enable preserving whitespaces by adding `preserveWhitespaces: true` to your tsconfig, it is possible you may encounter issues with hydration. This is not yet a fully supported configuration.

使用水合功能时，我们建议对 `preserveWhitespaces` 使用默认设置 `false`。如果你的 tsconfig 中没有进行此设置，则该值将为 `false` 而无需更改。如果你选择通过将 `preserveWhitespaces: true` 添加到你的 tsconfig 中来启用保留空格，就可能会遇到水合问题。这在目前还不是一个受到完全支持的配置。

Custom or Noop Zone.js are not yet supported

尚不支持自定义或 Noop Zone.js

Hydration relies on a signal from Zone.js when it becomes stable inside an application, so that Angular can start the serialization process on the server or post-hydration cleanup on the client to remove DOM nodes that remained unclaimed.

水合要依赖于来自 Zone.js 的信号来确定应用程序何时变得稳定，以便 Angular 可以在服务端上启动序列化过程或在客户端启动水合后进行清理工作（以删除无主的 DOM 节点）。

Providing a custom or a "noop" Zone.js implementation may lead to a different timing of the "stable" event, thus triggering the serialization or the cleanup too early or too late. This is not yet a fully supported configuration and you may need to adjust the timing of the `onStable` event in the custom Zone.js implementation.

提供自定义或 “noop” Zone.js 实现可能会导致“稳定”事件发生在不同的时间点，从而过早或过晚触发序列化或清理。这还不是已受完全支持的配置，你可能需要在自定义 Zone.js 实现中调整 `onStable` 事件的时间。

<a id="errors"></a>



Errors

错误

There are several hydration related errors you may encounter ranging from node mismatches to cases when the `ngSkipHydration` was used on an invalid host node. The most common error case that may occur is due to direct DOM manipulation using native APIs that results in hydration being unable to find or match the expected DOM tree structure on the client that was rendered by the server. The other case you may encounter this type of error was mentioned in the prior section on Valid HTML structures. So, make sure the HTML in your templates are using valid structure, and you'll avoid that error case.

你可能会遇到多种与水合相关的错误，从节点不匹配，到在无效宿主节点上使用 `ngSkipHydration` 等情况。可能发生的最常见错误情况是由于使用了原生 API 直接进行 DOM 操作导致水合无法在客户端上找到或匹配上服务端渲染的预期 DOM 树结构。另一种情况已在前面有关有效 HTML 结构的部分中提到过。因此，请确保你模板中的 HTML 使用了有效结构，这样就可以避免这种错误情况。

For a full reference on hydration related errors, visit the [Errors Reference Guide](/errors).

有关水合相关错误的完整参考，请访问[错误参考指南](/errors)。

<a id="ngskiphydration"></a>



How to skip hydration for particular components

如何跳过特定组件的水合

Some components may not work properly with hydration enabled due to some of the aforementioned issues, like direct DOM manipulation. As a workaround, you can add the `ngSkipHydration` attribute to a component's tag in order to skip hydrating the entire component.

由于上述某些问题（例如直接操作 DOM），某些组件可能在启用水合的情况下无法正常工作。作为一种变通方法，你可以将 `ngSkipHydration` 属性添加到组件的标签中，以跳过对整个组件进行水合处理。

Alternatively you can set `ngSkipHydration` as a host binding.

或者，你可以在宿主绑定中使用 `ngSkipHydration`。

The `ngSkipHydration` attribute will force Angular to skip hydrating the entire component and its children. Using this attribute means that the component will behave as if hydration is not enabled, meaning it will destroy and re-render itself.

`ngSkipHydration` 属性将强制 Angular 跳过对整个组件及其子组件的水合。使用此属性意味着该组件的行为就像未启用水合一样，这意味着它将自行销毁并重新渲染。

The `ngSkipHydration` attribute can only be used on component host nodes. Angular throws an error if this attribute is added to other nodes.

`ngSkipHydration` 属性只能在组件的宿主节点上使用。如果将此属性添加到其他节点，Angular 就会抛出错误。

Keep in mind that adding the `ngSkipHydration` attribute to your root application component would effectively disable hydration for your entire application. Be careful and thoughtful about using this attribute. It is intended as a last resort workaround. Components that break hydration should be considered bugs that need to be fixed.

请记住，将 `ngSkipHydration` 属性添加到根应用程序组件将有效地禁用对整个应用程序的水合。因此使用此属性时要小心谨慎，它只能作为最后的解决方案。那些破坏水合的组件应被视为需要修复的错误。

<a id="i18n"></a>



I18N



We don't yet support internationalization with hydration, but support is coming.
Currently, Angular would skip hydration for components that use i18n blocks, effectively
re-rendering those components from scratch.

我们还不支持水合的国际化，但很快就会支持。目前，Angular 会跳过对使用了 i18n 块的组件的水合，有效地从头开始重新渲染这些组件。

Third Party Libraries with DOM Manipulation

具有 DOM 操作的第三方库

There are a number of third party libraries that depend on DOM manipulation to be able to render. D3 charts is a prime example. These libraries worked without hydration, but they may cause DOM mismatch errors when hydration is enabled. For now, if you encounter DOM mismatch errors using one of these libraries, you can add the `ngSkipHydration` attribute to the component that renders using that library.

有许多依赖于 DOM 操作才能渲染的第三方库。D3 图表就是典型。这些库在没有水合的情况下能正常工作，但在启用水合时可能会导致 DOM 不匹配错误。现在，如果你在使用这些库之一时遇到了 DOM 不匹配的错误，可以将 `ngSkipHydration` 属性添加到使用该库渲染的组件。