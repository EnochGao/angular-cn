Optimize variables declared and used in the IR.

优化 IR 中声明和使用的变量。

Variables are eagerly generated by pipeline stages for all possible values that could be
referenced. This stage processes the list of declared variables and all variable usages,
and optimizes where possible. It performs 3 main optimizations:

流水线阶段急切地为可以引用的所有可能值生成变量。此阶段处理声明变量列表和所有变量用法，并在可能的情况下进行优化。它执行 3 个主要优化：

It transforms variable declarations to side effectful expressions when the
variable is not used, but its initializer has global effects which other
operations rely upon.

当不使用变量时，它将变量声明转换为副作用表达式，但它的初始化程序具有其他操作所依赖的全局效果。

It removes variable declarations if those variables are not referenced and
either they do not have global effects, or nothing relies on them.

如果这些变量未被引用并且它们没有全局影响，或者没有任何依赖它们，它会删除变量声明。

It inlines variable declarations when those variables are only used once
and the inlining is semantically safe.

当这些变量只使用一次并且内联在语义上是安全的时，它会内联变量声明。

To guarantee correctness, analysis of "fences" in the instruction lists is used to determine
which optimizations are safe to perform.

为了保证正确性，指令列表中的“围栏”分析用于确定执行哪些优化是安全的。

A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates
how that expression can be optimized in relation to other expressions or instructions.

表达式的[栅栏](https://en.wikipedia.org/wiki/Memory_barrier)标志，指示如何相对于其他表达式或指令优化该表达式。

`Fence`s are a bitfield, so multiple flags may be set on a single expression.

`Fence` 是位域，因此可以在单个表达式上设置多个标志。

Empty flag \(no fence exists\).

空标志（不存在栅栏）。

A context read fence, meaning that the expression in question reads from the "current view"
context of the runtime.

上下文读取栅栏，意味着相关表达式从运行时的“当前视图”上下文中读取。

A context write fence, meaning that the expression in question writes to the "current view"
context of the runtime.

上下文写栅栏，意味着所讨论的表达式写入运行时的“当前视图”上下文。

Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which
change the view context do so based on the current one.

请注意，所有 `ContextWrite` 栅栏都是隐式的 `ContextRead` 栅栏，因为更改视图上下文的操作是基于当前视图上下文执行的。

Indicates that a call is required for its side-effects, even if nothing reads its result.

表示需要对其副作用进行调用，即使没有任何内容读取其结果。

This is also true of `ViewContextWrite` operations **if** they are followed by a
`ViewContextRead`.

**如果**`ViewContextWrite` 操作后跟 `ViewContextRead`，这也是如此。

Summary data collected for each `Op` in a list.

为列表中的每个 `Op` 收集的摘要数据。

Tracking this data per operation allows the optimizer to process operations at a higher level
than always scanning expressions.

跟踪每个操作的数据允许优化器在比始终扫描表达式更高的级别处理操作。

A `Set` of variables referenced by expressions in this operation.

此操作中的表达式引用的一 `Set` 变量。

Flags indicating any `Fence`s present for this operation.

指示此操作存在的任何 `Fence` 的标志。

Process a list of operations and optimize variables within that list.

处理操作列表并优化该列表中的变量。

Given an `ir.Expression`, returns the `Fence` flags for that expression type.

给定一个 `ir.Expression`，返回该表达式类型的 `Fence` 标志。

Build the `OpInfo` structure for the given `op`. This performs two operations:

为给定的 `op` 构建 `OpInfo` 结构。这执行两个操作：

It tracks which variables are used in the operation's expressions.

它跟踪操作表达式中使用了哪些变量。

It rolls up fence flags for expressions within the operation.

它为操作中的表达式汇总栅栏标志。

Count the number of usages of each variable, being careful to track whether those usages are
local or remote.

计算每个变量的使用次数，注意跟踪这些使用是本地的还是远程的。

Remove usages of a variable in `op` from the `varUsages` tracking.

从 `varUsages` 跟踪中删除 `op` 中变量的使用。

the fences of the operation which the inlining will cross

内联将跨越的操作的围栏

the fences of the variable being inlined.

内联变量的栅栏。

Checks whether it's safe to inline a variable across a particular operation.

检查在特定操作中内联变量是否安全。

Attempt to inline the initializer of a variable into a target operation's expressions.

尝试将变量的初始值设定项内联到目标操作的表达式中。

This may or may not be safe to do. For example, the variable could be read following the
execution of an expression with fences that don't permit the variable to be inlined across them.

这样做可能安全也可能不安全。例如，可以在执行带有不允许变量跨过它们内联的栅栏的表达式后读取变量。

Determines whether inlining of `decl` should be allowed in "conservative" mode.

确定在“保守”模式下是否应允许 `decl` 内联。

In conservative mode, inlining behavior is limited to those operations which the
`TemplateDefinitionBuilder` supported, with the goal of producing equivalent output.

在保守模式下，内联行为仅限于 `TemplateDefinitionBuilder` 支持的那些操作，目的是产生等效输出。